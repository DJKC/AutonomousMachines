#pragma config(Sensor, dgtl6,  shaft_1,        sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  bottom_lever,   sensorTouch)
#pragma config(Sensor, dgtl10, floor_1,        sensorTouch)
#pragma config(Sensor, dgtl11, floor_2,        sensorTouch)
#pragma config(Sensor, dgtl12, floor_3,        sensorTouch)
#pragma config(Motor,  port8,           left_motor,    tmotorVex269, openLoop)
#pragma config(Motor,  port9,           right_motor,   tmotorVex269, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#pragma config(Sensor, dgtl8,  top_lever,      sensorTouch)

//*!!Code generated by that awesome team              !!*//

typedef enum{
	FIRST = 0,
	SECOND = -400,
	THIRD = -800,
} Floors;

typedef enum{
	UP = 1,
	DOWN = -1,
} Direction;

/*typedef struct{
	int floors;
	Direction direction;
} movement;*/

void move_to_floor(int current_floorr, Floors dest);
//function moves the elevator to the specified floor
//parameter floor is the floor to be taken to

void move_to_bottom();
//function moves the elevator to the lowest floor
//takesno parameters

void move_motors(int speed);
//function moves the motors
//parameter speed is the speed to move the motor
//	126 max for motor speed

int current_floor();
//
//

int check_direction(int floor_current, int floor_user);
//
//

int convert_Floor_to_int(Floors the_floor);
//
//

int convert_Floor_to_shaft(Floors the_floor);
//
//

task main()
{
	move_to_bottom();

	wait1Msec(2000);

	do{
		if(SensorValue(floor_1) == 1){
			move_to_floor(current_floor(), FIRST);

		}

		else if(SensorValue(floor_2) == 1){
			move_to_floor(current_floor(), SECOND);
		}

		else if(SensorValue(floor_3) == 1){
			move_to_floor(current_floor(), THIRD);
		}
	}while(true);

	move_motors(0);
}

void move_motors(int speed){
	motor[left_motor] = -1 * speed;
	motor[right_motor] = speed;

	return;
}

void move_to_floor(int current_floorr, Floors dest){
	while(SensorValue[shaft_1] != convert_Floor_to_shaft(dest)){
		if(check_direction(current_floorr, convert_Floor_to_int(dest)) > 0)
			move_motors(15);

		else if(check_direction(current_floorr, convert_Floor_to_int(dest)) < 0)
			move_motors(-1 * 20);
	}

	if(SensorValue[shaft_1] == dest)
		move_motors(0);

	//SensorValue[shaft_1] = destination;
}

void move_to_bottom(){
	while(SensorValue(bottom_lever) == 0)
		move_motors(-15);

	if(SensorValue(bottom_lever) == 1)
		move_motors(0);

	SensorValue[shaft_1] = 0;

	return;
}

int check_direction(int floor_current, int floor_user){
	int move_direction = floor_user - floor_current;

	if(move_direction > 0)//moves up a floor
		return 1;

	else if(move_direction == 0)//if moves to same floor
		return 0;

	else if(move_direction < 0)//moves down a floor
		return -1;

	else
		return 0;
}

int current_floor(){
	if(SensorValue[shaft_1] == THIRD)
		return 3;

	else if(SensorValue[shaft_1] == SECOND)// && SensorValue[shaft_1] > floors.FIRST){
		return 2;

	else if(SensorValue[shaft_1] == FIRST)
		return 1;

	else
		return 0;
}

int convert_Floor_to_int(Floors the_floor){
	int floor_to_int;

	if(the_floor == FIRST)
		floor_to_int = 1;

	else if(the_floor == SECOND)
		floor_to_int = 2;

	else if(the_floor == THIRD)
		floor_to_int = 3;

	return floor_to_int;
}

int convert_Floor_to_shaft(Floors the_floor){
	int floor_to_shaft;

	if(the_floor == FIRST)
		floor_to_shaft = 0;

	else if(the_floor == SECOND)
		floor_to_shaft = -400;

	else if(the_floor == THIRD)
		floor_to_shaft = -800;

	return floor_to_shaft;
}

bool floor_reached(){

}
